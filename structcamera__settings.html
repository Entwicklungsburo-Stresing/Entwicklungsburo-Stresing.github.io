<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EBST_CAM: camera_settings Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="CCD.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="CCD.ico"/></td>
  <td id="projectalign">
   <div id="projectname">EBST_CAM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structcamera__settings-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">camera_settings Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Individual settings for each PCIe board.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="struct_8h_source.html">struct.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7d6d06fc3f59976df702bfda1e7bc0d1" id="r_a7d6d06fc3f59976df702bfda1e7bc0d1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d6d06fc3f59976df702bfda1e7bc0d1">use_software_polling</a></td></tr>
<tr class="separator:a7d6d06fc3f59976df702bfda1e7bc0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb4693c3f62bd567f9063c0412035b5" id="r_afeb4693c3f62bd567f9063c0412035b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb4693c3f62bd567f9063c0412035b5">sti_mode</a></td></tr>
<tr class="separator:afeb4693c3f62bd567f9063c0412035b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6578f775f4bbad6da1ec2d85323a8458" id="r_a6578f775f4bbad6da1ec2d85323a8458"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6578f775f4bbad6da1ec2d85323a8458">bti_mode</a></td></tr>
<tr class="separator:a6578f775f4bbad6da1ec2d85323a8458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e94844da7b9228d8ba9c2bd14310cb" id="r_a10e94844da7b9228d8ba9c2bd14310cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10e94844da7b9228d8ba9c2bd14310cb">stime</a></td></tr>
<tr class="separator:a10e94844da7b9228d8ba9c2bd14310cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6f87c7fca887ea0bc1f5f16ff90f94" id="r_a0f6f87c7fca887ea0bc1f5f16ff90f94"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6f87c7fca887ea0bc1f5f16ff90f94">btime</a></td></tr>
<tr class="separator:a0f6f87c7fca887ea0bc1f5f16ff90f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbb58aa78c6d9d9210c244507de9c68" id="r_afdbb58aa78c6d9d9210c244507de9c68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdbb58aa78c6d9d9210c244507de9c68">sdat_in_10ns</a></td></tr>
<tr class="separator:afdbb58aa78c6d9d9210c244507de9c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2139e71363af04fb3558bbc94057bbb" id="r_ad2139e71363af04fb3558bbc94057bbb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2139e71363af04fb3558bbc94057bbb">bdat_in_10ns</a></td></tr>
<tr class="separator:ad2139e71363af04fb3558bbc94057bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f55940576ecb2bced3027d38676ea5c" id="r_a6f55940576ecb2bced3027d38676ea5c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f55940576ecb2bced3027d38676ea5c">sslope</a></td></tr>
<tr class="separator:a6f55940576ecb2bced3027d38676ea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2f5116d777038bcb58543db3caf877" id="r_aad2f5116d777038bcb58543db3caf877"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2f5116d777038bcb58543db3caf877">bslope</a></td></tr>
<tr class="separator:aad2f5116d777038bcb58543db3caf877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b34c90094bcbc83b418f3b613f6c8d7" id="r_a7b34c90094bcbc83b418f3b613f6c8d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b34c90094bcbc83b418f3b613f6c8d7">xckdelay_in_10ns</a></td></tr>
<tr class="separator:a7b34c90094bcbc83b418f3b613f6c8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef56c9e33dc855c930fd7d44588cbcd" id="r_adef56c9e33dc855c930fd7d44588cbcd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef56c9e33dc855c930fd7d44588cbcd">sec_in_10ns</a></td></tr>
<tr class="separator:adef56c9e33dc855c930fd7d44588cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d92a0475fbf332ef99de9748d6b197" id="r_a81d92a0475fbf332ef99de9748d6b197"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d92a0475fbf332ef99de9748d6b197">trigger_mode_integrator</a></td></tr>
<tr class="separator:a81d92a0475fbf332ef99de9748d6b197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95b63babcb2222a271e2cd42b6e057" id="r_a3c95b63babcb2222a271e2cd42b6e057"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c95b63babcb2222a271e2cd42b6e057">sensor_type</a></td></tr>
<tr class="separator:a3c95b63babcb2222a271e2cd42b6e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab782cf8240d4a3400170ade96a4d11fd" id="r_ab782cf8240d4a3400170ade96a4d11fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab782cf8240d4a3400170ade96a4d11fd">camera_system</a></td></tr>
<tr class="separator:ab782cf8240d4a3400170ade96a4d11fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4738ff8e4057123c2c7136a8ac585bea" id="r_a4738ff8e4057123c2c7136a8ac585bea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4738ff8e4057123c2c7136a8ac585bea">camcnt</a></td></tr>
<tr class="separator:a4738ff8e4057123c2c7136a8ac585bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487b9bad9fa6aca6b18b4742c8ce417" id="r_ad487b9bad9fa6aca6b18b4742c8ce417"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad487b9bad9fa6aca6b18b4742c8ce417">pixel</a></td></tr>
<tr class="separator:ad487b9bad9fa6aca6b18b4742c8ce417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b126accc9d7980b594d7256f767e1cb" id="r_a3b126accc9d7980b594d7256f767e1cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b126accc9d7980b594d7256f767e1cb">is_fft_legacy</a></td></tr>
<tr class="separator:a3b126accc9d7980b594d7256f767e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b70539f225998b06fe9af05148e6fc3" id="r_a1b70539f225998b06fe9af05148e6fc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b70539f225998b06fe9af05148e6fc3">led_off</a></td></tr>
<tr class="separator:a1b70539f225998b06fe9af05148e6fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aefaf11767a16726f85379d288895b" id="r_ac7aefaf11767a16726f85379d288895b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7aefaf11767a16726f85379d288895b">sensor_gain</a></td></tr>
<tr class="separator:ac7aefaf11767a16726f85379d288895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cdd5f01634be12f124d513081a1249" id="r_a41cdd5f01634be12f124d513081a1249"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41cdd5f01634be12f124d513081a1249">adc_gain</a></td></tr>
<tr class="separator:a41cdd5f01634be12f124d513081a1249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949285bc39a601900f8d975444e492d" id="r_a5949285bc39a601900f8d975444e492d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5949285bc39a601900f8d975444e492d">temp_level</a></td></tr>
<tr class="separator:a5949285bc39a601900f8d975444e492d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a526f3452aa41931041f6bb05166f08" id="r_a9a526f3452aa41931041f6bb05166f08"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a526f3452aa41931041f6bb05166f08">bticnt</a></td></tr>
<tr class="separator:a9a526f3452aa41931041f6bb05166f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e618626ec640a5733b33745e844d15" id="r_ad9e618626ec640a5733b33745e844d15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e618626ec640a5733b33745e844d15">gpx_offset</a></td></tr>
<tr class="separator:ad9e618626ec640a5733b33745e844d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f4f26e7f43bf7f40bef828ac5849e0" id="r_a74f4f26e7f43bf7f40bef828ac5849e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f4f26e7f43bf7f40bef828ac5849e0">fft_lines</a></td></tr>
<tr class="separator:a74f4f26e7f43bf7f40bef828ac5849e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34276300a6c0e2a56a8404b73ad8de" id="r_a2e34276300a6c0e2a56a8404b73ad8de"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e34276300a6c0e2a56a8404b73ad8de">vfreq</a></td></tr>
<tr class="separator:a2e34276300a6c0e2a56a8404b73ad8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5b9370309e2391bdc0bdfbf7e9df15" id="r_a9a5b9370309e2391bdc0bdfbf7e9df15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a5b9370309e2391bdc0bdfbf7e9df15">fft_mode</a></td></tr>
<tr class="separator:a9a5b9370309e2391bdc0bdfbf7e9df15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b33889efd68e6ad8216c48d2941a8e" id="r_a11b33889efd68e6ad8216c48d2941a8e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b33889efd68e6ad8216c48d2941a8e">lines_binning</a></td></tr>
<tr class="separator:a11b33889efd68e6ad8216c48d2941a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba505c7ed0e5a7488ea20f4caf52675b" id="r_aba505c7ed0e5a7488ea20f4caf52675b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba505c7ed0e5a7488ea20f4caf52675b">number_of_regions</a></td></tr>
<tr class="separator:aba505c7ed0e5a7488ea20f4caf52675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725f47b587a2b425688fbd79586b989e" id="r_a725f47b587a2b425688fbd79586b989e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725f47b587a2b425688fbd79586b989e">s1s2_read_delay_in_10ns</a></td></tr>
<tr class="separator:a725f47b587a2b425688fbd79586b989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa31e4964a41c592d24ce74e4b7ce41" id="r_a3fa31e4964a41c592d24ce74e4b7ce41"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa31e4964a41c592d24ce74e4b7ce41">region_size</a> [<a class="el" href="struct_8h.html#aec6ccacce4c15681a97f2edc0521040e">MAX_NUMBER_OF_REGIONS</a>]</td></tr>
<tr class="separator:a3fa31e4964a41c592d24ce74e4b7ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59edb2a2bc34f1da3c62c5ab77293b75" id="r_a59edb2a2bc34f1da3c62c5ab77293b75"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59edb2a2bc34f1da3c62c5ab77293b75">dac_output</a> [<a class="el" href="struct_8h.html#a62afa1e27890bd027549e82cc4be5bd9">MAXCAMCNT</a>][<a class="el" href="struct_8h.html#a012d7c6bb56a23927e1068ab8857d1e2">DACCOUNT</a>]</td></tr>
<tr class="separator:a59edb2a2bc34f1da3c62c5ab77293b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a0cd5c6fc15fb192e18d623cffca0d" id="r_ac9a0cd5c6fc15fb192e18d623cffca0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a0cd5c6fc15fb192e18d623cffca0d">tor</a></td></tr>
<tr class="separator:ac9a0cd5c6fc15fb192e18d623cffca0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1f7b31ae0973dc8a3ca8579f851aa" id="r_af7e1f7b31ae0973dc8a3ca8579f851aa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e1f7b31ae0973dc8a3ca8579f851aa">adc_mode</a></td></tr>
<tr class="separator:af7e1f7b31ae0973dc8a3ca8579f851aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54be4b6539b096109c43abdf0a489fb7" id="r_a54be4b6539b096109c43abdf0a489fb7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54be4b6539b096109c43abdf0a489fb7">adc_custom_pattern</a></td></tr>
<tr class="separator:a54be4b6539b096109c43abdf0a489fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e4ecc9c93c9d84bcdf7dd92a0ced4c" id="r_a41e4ecc9c93c9d84bcdf7dd92a0ced4c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41e4ecc9c93c9d84bcdf7dd92a0ced4c">bec_in_10ns</a></td></tr>
<tr class="separator:a41e4ecc9c93c9d84bcdf7dd92a0ced4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e2141ac18c56f46722ae451f9125c" id="r_a362e2141ac18c56f46722ae451f9125c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a362e2141ac18c56f46722ae451f9125c">channel_select</a></td></tr>
<tr class="separator:a362e2141ac18c56f46722ae451f9125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da76423332a875434a8524c0aeb652d" id="r_a9da76423332a875434a8524c0aeb652d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da76423332a875434a8524c0aeb652d">ioctrl_impact_start_pixel</a></td></tr>
<tr class="separator:a9da76423332a875434a8524c0aeb652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16029e5a3e58705e7af44c9b268d7015" id="r_a16029e5a3e58705e7af44c9b268d7015"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16029e5a3e58705e7af44c9b268d7015">ioctrl_output_width_in_5ns</a> [<a class="el" href="struct_8h.html#a6f13d93331834d5a48b2b252b3c4a578">IOCTRL_OUTPUT_COUNT</a>]</td></tr>
<tr class="separator:a16029e5a3e58705e7af44c9b268d7015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcde4b0ee2cb3c896e99b599d5c4d46b" id="r_abcde4b0ee2cb3c896e99b599d5c4d46b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcde4b0ee2cb3c896e99b599d5c4d46b">ioctrl_output_delay_in_5ns</a> [<a class="el" href="struct_8h.html#a6f13d93331834d5a48b2b252b3c4a578">IOCTRL_OUTPUT_COUNT</a>]</td></tr>
<tr class="separator:abcde4b0ee2cb3c896e99b599d5c4d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7884cc77b6263bfaea25f24215bfe83e" id="r_a7884cc77b6263bfaea25f24215bfe83e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7884cc77b6263bfaea25f24215bfe83e">ioctrl_T0_period_in_10ns</a></td></tr>
<tr class="separator:a7884cc77b6263bfaea25f24215bfe83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2833d2036671abc6382415794d6032" id="r_a8f2833d2036671abc6382415794d6032"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2833d2036671abc6382415794d6032">dma_buffer_size_in_scans</a></td></tr>
<tr class="separator:a8f2833d2036671abc6382415794d6032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d36d06df4f4506a30632260bf6b1939" id="r_a9d36d06df4f4506a30632260bf6b1939"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d36d06df4f4506a30632260bf6b1939">tocnt</a></td></tr>
<tr class="separator:a9d36d06df4f4506a30632260bf6b1939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95629ef99d7173af90b835efd29b4eb9" id="r_a95629ef99d7173af90b835efd29b4eb9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95629ef99d7173af90b835efd29b4eb9">sticnt</a></td></tr>
<tr class="separator:a95629ef99d7173af90b835efd29b4eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e848de09b699a99f976b67297acbd15" id="r_a2e848de09b699a99f976b67297acbd15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e848de09b699a99f976b67297acbd15">sensor_reset_or_hsir_ec</a></td></tr>
<tr class="separator:a2e848de09b699a99f976b67297acbd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87115a7a52a7b6f474bb12ab3a2db076" id="r_a87115a7a52a7b6f474bb12ab3a2db076"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87115a7a52a7b6f474bb12ab3a2db076">write_to_disc</a></td></tr>
<tr class="separator:a87115a7a52a7b6f474bb12ab3a2db076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87267de87e955bd0f244798f48d0c6df" id="r_a87267de87e955bd0f244798f48d0c6df"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87267de87e955bd0f244798f48d0c6df">file_path</a> [<a class="el" href="enum__settings_8h.html#a4ba27b32532ad58360b3aeec14e84897a0cbddb1cbe6c35a91865e73cac587eaf">file_path_size</a>]</td></tr>
<tr class="separator:a87267de87e955bd0f244798f48d0c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fa99eaf64c0df8af0ffd6ce1b5497c" id="r_a02fa99eaf64c0df8af0ffd6ce1b5497c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02fa99eaf64c0df8af0ffd6ce1b5497c">shift_s1s2_to_next_scan</a></td></tr>
<tr class="separator:a02fa99eaf64c0df8af0ffd6ce1b5497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d482c6345afb2116315167cf04b42d" id="r_a12d482c6345afb2116315167cf04b42d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12d482c6345afb2116315167cf04b42d">is_cooled_camera_legacy_mode</a></td></tr>
<tr class="separator:a12d482c6345afb2116315167cf04b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e6684676f13947b082dd5e7ab225b5" id="r_a87e6684676f13947b082dd5e7ab225b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e6684676f13947b082dd5e7ab225b5">monitor</a></td></tr>
<tr class="separator:a87e6684676f13947b082dd5e7ab225b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d24d1e3326657499f0c1ec387d005" id="r_a108d24d1e3326657499f0c1ec387d005"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a108d24d1e3326657499f0c1ec387d005">manipulate_data_mode</a></td></tr>
<tr class="separator:a108d24d1e3326657499f0c1ec387d005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98246d4ee9f663d7b468f71821d7632" id="r_ab98246d4ee9f663d7b468f71821d7632"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98246d4ee9f663d7b468f71821d7632">manipulate_data_custom_factor</a></td></tr>
<tr class="separator:ab98246d4ee9f663d7b468f71821d7632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bcfff32281c4c321aba130fb4c4f09" id="r_a40bcfff32281c4c321aba130fb4c4f09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40bcfff32281c4c321aba130fb4c4f09">ec_legacy_mode</a></td></tr>
<tr class="separator:a40bcfff32281c4c321aba130fb4c4f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb5552267c411cc54baf8b800967ead" id="r_a8bb5552267c411cc54baf8b800967ead"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb5552267c411cc54baf8b800967ead">timer_resolution_mode</a></td></tr>
<tr class="separator:a8bb5552267c411cc54baf8b800967ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Individual settings for each PCIe board. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a54be4b6539b096109c43abdf0a489fb7" name="a54be4b6539b096109c43abdf0a489fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54be4b6539b096109c43abdf0a489fb7">&#9670;&#160;</a></span>adc_custom_pattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::adc_custom_pattern</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adc custom pattern is the constant output value of all 8 ADC channels if <a class="el" href="#af7e1f7b31ae0973dc8a3ca8579f851aa">camera_settings::adc_mode</a> is set to <a class="el" href="enum__settings_8h.html#a760a8dafdcddcfadfea0aa3e01159164a4a7a5bdd9acf4b955bb227d97d92f3a9">adc_mode_t::custom_pattern</a>. This is a 14 bit unsigned integer.</p><ul>
<li>min: 0</li>
<li>step: 1</li>
<li>max: 16383 </li>
</ul>

</div>
</div>
<a id="a41cdd5f01634be12f124d513081a1249" name="a41cdd5f01634be12f124d513081a1249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cdd5f01634be12f124d513081a1249">&#9670;&#160;</a></span>adc_gain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::adc_gain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC gain is controlling the gain function of the ADC in 3030 high speed cameras. ADC gain is a 8 bit unsigned integer. Further information about adc_gain can be found in the manual in chapter 3.4.2.1.</p><ul>
<li>min: 0</li>
<li>step: 1</li>
<li>default: 6</li>
<li>max: 12 </li>
</ul>

</div>
</div>
<a id="af7e1f7b31ae0973dc8a3ca8579f851aa" name="af7e1f7b31ae0973dc8a3ca8579f851aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e1f7b31ae0973dc8a3ca8579f851aa">&#9670;&#160;</a></span>adc_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::adc_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC mode controls the operating mode of the ADC. This option is intended for debugging purpose and only available for specific ADCs, e.g. in camera system 3030. See enum <a class="el" href="enum__settings_8h.html#a760a8dafdcddcfadfea0aa3e01159164">adc_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="ad2139e71363af04fb3558bbc94057bbb" name="ad2139e71363af04fb3558bbc94057bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2139e71363af04fb3558bbc94057bbb">&#9670;&#160;</a></span>bdat_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::bdat_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block delay after trigger in 10 ns steps. This is the delay between the trigger starting a block, which is determined by bti_mode and the actual start of the block. BDAT is a 31 bit unsigned integer. Further information about bdat can be found in the manual in chapter 2.9.2 and 6.2.6.2.</p><ul>
<li>disable: 0</li>
<li>min: 1 * 10 ns = 10 ns</li>
<li>step: 10 ns</li>
<li>max: 2,147,483,647 * 10 ns = 21,474,836,470 ns = 21.474836470 s </li>
</ul>

</div>
</div>
<a id="a41e4ecc9c93c9d84bcdf7dd92a0ced4c" name="a41e4ecc9c93c9d84bcdf7dd92a0ced4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e4ecc9c93c9d84bcdf7dd92a0ced4c">&#9670;&#160;</a></span>bec_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::bec_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block exposure control in 10 ns steps adds a delay time between the block trigger and the start start of the block. Mechanical shutters can be controlled with this setting. The BEC time is added between the end of BDAT and the start of the block. BEC is a 32 bit unsigned integer. Further information about BEC can be found in the manual in chapter 4.9.1 and 6.2.6.3.</p><ul>
<li>disable: 0</li>
<li>min: 1 * 10 ns = 10 ns</li>
<li>step: 10 ns</li>
<li>max: 4,294,967,295 * 10 ns = 42,949,672,950 ns </li>
</ul>

</div>
</div>
<a id="aad2f5116d777038bcb58543db3caf877" name="aad2f5116d777038bcb58543db3caf877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2f5116d777038bcb58543db3caf877">&#9670;&#160;</a></span>bslope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::bslope</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block trigger slope determines whether positive, negative or both slopes of a trigger are used. See enum <a class="el" href="enum__settings_8h.html#a6e2fb72f49966ca5028850e2e30dc586">bslope_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. This only applies to external triggers. </p>

</div>
</div>
<a id="a6578f775f4bbad6da1ec2d85323a8458" name="a6578f775f4bbad6da1ec2d85323a8458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6578f775f4bbad6da1ec2d85323a8458">&#9670;&#160;</a></span>bti_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::bti_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block trigger input mode determines the signal, on which one block of readouts is started. See enum <a class="el" href="enum__settings_8h.html#a2fce6aa348483bc730e1693a39bc0e00">bti_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information on trigger signals can be found in the manual in chapter 6.3. </p>

</div>
</div>
<a id="a9a526f3452aa41931041f6bb05166f08" name="a9a526f3452aa41931041f6bb05166f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a526f3452aa41931041f6bb05166f08">&#9670;&#160;</a></span>bticnt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::bticnt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block trigger input counter determines how many block trigger inputs are skipped before the next block start is triggered. Every bticnt+1 trigger input the next block is triggered according to <a class="el" href="#a6578f775f4bbad6da1ec2d85323a8458">camera_settings::bti_mode</a>. bticnt is a 7 bit unsigned integer. Introduced in PCIe board version 222.12.</p><ul>
<li>min: 0</li>
<li>step: 1</li>
<li>max: 127 </li>
</ul>

</div>
</div>
<a id="a0f6f87c7fca887ea0bc1f5f16ff90f94" name="a0f6f87c7fca887ea0bc1f5f16ff90f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6f87c7fca887ea0bc1f5f16ff90f94">&#9670;&#160;</a></span>btime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::btime</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block time is the time between the start of two blocks of readouts. This time is used when <a class="el" href="#a6578f775f4bbad6da1ec2d85323a8458">camera_settings::bti_mode</a> is set to <a class="el" href="enum__settings_8h.html#a2fce6aa348483bc730e1693a39bc0e00aa80f3bc2af101fdd46dee4793eb0d906">bti_mode_t::bti_BTimer</a>. The resolution of this timer depends on the setting <a class="el" href="#a8bb5552267c411cc54baf8b800967ead">camera_settings::timer_resolution_mode</a>. Btime is a 28 bit unsigned integer. Further information about the timer can be found in the manual in chapter 6.4.4. </p>

</div>
</div>
<a id="a4738ff8e4057123c2c7136a8ac585bea" name="a4738ff8e4057123c2c7136a8ac585bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4738ff8e4057123c2c7136a8ac585bea">&#9670;&#160;</a></span>camcnt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::camcnt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Camcnt is the number of cameras which are connected to one PCIe board. This could be multiple cameras connected via a chain to one PCIe board or multiple channel on one camera control box. 0 is a valid input for operating a PCIe card without any camera connected and only use its special inputs. Camcnt is a 4 bit unsigned integer.</p><ul>
<li>Min: 0</li>
<li>Max: 15 </li>
</ul>

</div>
</div>
<a id="ab782cf8240d4a3400170ade96a4d11fd" name="ab782cf8240d4a3400170ade96a4d11fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab782cf8240d4a3400170ade96a4d11fd">&#9670;&#160;</a></span>camera_system</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::camera_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Camera system should match the model number of your camera. See enum <a class="el" href="enum__settings_8h.html#a87d071078d7c7603069e44ced5c5ebfe">camera_system_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="a362e2141ac18c56f46722ae451f9125c" name="a362e2141ac18c56f46722ae451f9125c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362e2141ac18c56f46722ae451f9125c">&#9670;&#160;</a></span>channel_select</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::channel_select</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Channel select controls which channel of a camera control box is used for the camera readout. This feature is implemented in the camera version P230_6 and newer. See enum <a class="el" href="enum__settings_8h.html#a5baa77ee33be73547f4e348a68da6e3e">channel_select_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="a59edb2a2bc34f1da3c62c5ab77293b75" name="a59edb2a2bc34f1da3c62c5ab77293b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59edb2a2bc34f1da3c62c5ab77293b75">&#9670;&#160;</a></span>dac_output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::dac_output[<a class="el" href="struct_8h.html#a62afa1e27890bd027549e82cc4be5bd9">MAXCAMCNT</a>][<a class="el" href="struct_8h.html#a012d7c6bb56a23927e1068ab8857d1e2">DACCOUNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Array for output levels of each digital to analog converter </p>

</div>
</div>
<a id="a8f2833d2036671abc6382415794d6032" name="a8f2833d2036671abc6382415794d6032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2833d2036671abc6382415794d6032">&#9670;&#160;</a></span>dma_buffer_size_in_scans</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::dma_buffer_size_in_scans</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the DMA buffer in scans. The default is 1000. This setting controls how often the interrupt is triggered to copy data from the DMA buffer to the user buffer. This setting only has an effect when <a class="el" href="#a7d6d06fc3f59976df702bfda1e7bc0d1">camera_settings::use_software_polling</a> is turned off. A lower number means more interrupts in a shorter time and so more recent data available. Which data is available is indicated by <a class="el" href="_e_s_l_s_c_d_l_l_8c.html#a79a1ea8d164b02336350f228840b1c02">DLLGetCurrentScanNumber</a>. Too many interrupts in a too short time can lead to errors. 60 is working with high speed (exposure time = 0,02ms). When this setting is 30, there could a wrong scan every 10000 scans. </p>

</div>
</div>
<a id="a40bcfff32281c4c321aba130fb4c4f09" name="a40bcfff32281c4c321aba130fb4c4f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bcfff32281c4c321aba130fb4c4f09">&#9670;&#160;</a></span>ec_legacy_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::ec_legacy_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ec_legacy_mode is a special mode for operating older high speed cameras, camera system 3030. The following camera versions need to be run in legacy mode:</p><ul>
<li>209.12 and older</li>
<li>= 0 off</li>
<li>&gt; 0 ec legacy mode on </li>
</ul>

</div>
</div>
<a id="a74f4f26e7f43bf7f40bef828ac5849e0" name="a74f4f26e7f43bf7f40bef828ac5849e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f4f26e7f43bf7f40bef828ac5849e0">&#9670;&#160;</a></span>fft_lines</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::fft_lines</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fft_lines is the count of vertical lines for FFT sensors. This setting should match your sensor. You can find this information in the manual. fft_lines is a 12 bit unsigned integer. Further information about FFT sensors can be found in the manual in chapters 1.4 and 11.3.3.</p><ul>
<li>min: 1</li>
<li>step: 1</li>
<li>default: 64</li>
<li>max: 4095 </li>
</ul>

</div>
</div>
<a id="a9a5b9370309e2391bdc0bdfbf7e9df15" name="a9a5b9370309e2391bdc0bdfbf7e9df15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5b9370309e2391bdc0bdfbf7e9df15">&#9670;&#160;</a></span>fft_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::fft_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fft_mode controls the operating mode for FFT sensors. The vertical lines of a FFT sensor can either be summed up, read separately or summed up partially. See enum <a class="el" href="enum__settings_8h.html#a86f1e46308bfcaf8ceccb822f1d72c57">fft_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information about FFT modes can be found in the manual in chapter 4.5.1. </p>

</div>
</div>
<a id="a87267de87e955bd0f244798f48d0c6df" name="a87267de87e955bd0f244798f48d0c6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87267de87e955bd0f244798f48d0c6df">&#9670;&#160;</a></span>file_path</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char camera_settings::file_path[<a class="el" href="enum__settings_8h.html#a4ba27b32532ad58360b3aeec14e84897a0cbddb1cbe6c35a91865e73cac587eaf">file_path_size</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File path is specifying the path where the measurement data is saved, when <a class="el" href="#a87115a7a52a7b6f474bb12ab3a2db076">camera_settings::write_to_disc</a> is activated. File path is a char array with the size 256, so the maximum path length is 256 characters.</p><ul>
<li>example value: C:/Users/XY/ </li>
</ul>

</div>
</div>
<a id="ad9e618626ec640a5733b33745e844d15" name="ad9e618626ec640a5733b33745e844d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e618626ec640a5733b33745e844d15">&#9670;&#160;</a></span>gpx_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::gpx_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>GPX offset is controlling the output offset of the TDC-GPX IC on the TDC add on board for the PCIe card. The TDC-GPX IC can be used to measure the time delay between one start and two stop signals in picosecond resolution. Adding an offset can improve the accuracy of the TDC-GPX IC. GPX offset is a 18 bit unsigned integer. Further information about gpx_offset can be found in the manual in chapter 10.2.</p><ul>
<li>min: 0</li>
<li>step: 1</li>
<li>default: 1000</li>
<li>max: 262,143 </li>
</ul>

</div>
</div>
<a id="a9da76423332a875434a8524c0aeb652d" name="a9da76423332a875434a8524c0aeb652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da76423332a875434a8524c0aeb652d">&#9670;&#160;</a></span>ioctrl_impact_start_pixel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::ioctrl_impact_start_pixel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IOCTRL impact start pixel is the position in the pixel array where the information of voltage or integrator inputs are written. The number of these inputs can differ, so length of these additional information can differ, too. The setting specifies the first pixel where the information is written, so the information can be read from this one and the following pixels. IOCTRL impact start pixel is a 16 bit unsigned integer. Further information about IOCTRL impact start pixel can be found in the manual in chapter 7.3.</p><ul>
<li>min: 23</li>
<li>step: 1</li>
<li>default: 1078</li>
<li>max: 65535 </li>
</ul>

</div>
</div>
<a id="abcde4b0ee2cb3c896e99b599d5c4d46b" name="abcde4b0ee2cb3c896e99b599d5c4d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcde4b0ee2cb3c896e99b599d5c4d46b">&#9670;&#160;</a></span>ioctrl_output_delay_in_5ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::ioctrl_output_delay_in_5ns[<a class="el" href="struct_8h.html#a6f13d93331834d5a48b2b252b3c4a578">IOCTRL_OUTPUT_COUNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an array, which sets the delay of the IOCTRL outputs in 5ns steps. </p>

</div>
</div>
<a id="a16029e5a3e58705e7af44c9b268d7015" name="a16029e5a3e58705e7af44c9b268d7015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16029e5a3e58705e7af44c9b268d7015">&#9670;&#160;</a></span>ioctrl_output_width_in_5ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::ioctrl_output_width_in_5ns[<a class="el" href="struct_8h.html#a6f13d93331834d5a48b2b252b3c4a578">IOCTRL_OUTPUT_COUNT</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an array, which sets the width of the IOCTRL outputs in 5ns steps. </p>

</div>
</div>
<a id="a7884cc77b6263bfaea25f24215bfe83e" name="a7884cc77b6263bfaea25f24215bfe83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7884cc77b6263bfaea25f24215bfe83e">&#9670;&#160;</a></span>ioctrl_T0_period_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::ioctrl_T0_period_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the base frequency T0 of the IOCTRL pulse generator in 10ns steps. </p>

</div>
</div>
<a id="a12d482c6345afb2116315167cf04b42d" name="a12d482c6345afb2116315167cf04b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d482c6345afb2116315167cf04b42d">&#9670;&#160;</a></span>is_cooled_camera_legacy_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::is_cooled_camera_legacy_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is cooled camera legacy is a special mode for operating older cooled cameras. If on, a bit in the PCIe board is set to react correctly to the cooled status messages from the camera. The following camera versions need to be run in legacy mode:</p><ul>
<li>208.X</li>
<li>218.1 and older</li>
<li>=0 off</li>
<li>&gt;0 cooled camera legacy mode on </li>
</ul>

</div>
</div>
<a id="a3b126accc9d7980b594d7256f767e1cb" name="a3b126accc9d7980b594d7256f767e1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b126accc9d7980b594d7256f767e1cb">&#9670;&#160;</a></span>is_fft_legacy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::is_fft_legacy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is fft legacy is a special legacy mode for operation with older FFT cameras. For the following camera versions fft legacy should be turned on:</p><ul>
<li>205.X</li>
<li>215.6 and older</li>
<li>208.X</li>
<li>218.3 and older</li>
<li>210.X</li>
<li>211.2 and older</li>
<li>206.X</li>
<li>216.X If the PCIe card version is 222.8 or older or 202.X, fft legacy should always be turned on, if you are using a FFT sensor. FFT legacy is available since 222.10.</li>
<li>=0: off (default)</li>
<li>&gt;0: fft legacy mode on </li>
</ul>

</div>
</div>
<a id="a1b70539f225998b06fe9af05148e6fc3" name="a1b70539f225998b06fe9af05148e6fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b70539f225998b06fe9af05148e6fc3">&#9670;&#160;</a></span>led_off</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::led_off</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LED off turns the LEDs in the camera off.</p><ul>
<li>=0 LED on</li>
<li>&gt;0 LED off </li>
</ul>

</div>
</div>
<a id="a11b33889efd68e6ad8216c48d2941a8e" name="a11b33889efd68e6ad8216c48d2941a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b33889efd68e6ad8216c48d2941a8e">&#9670;&#160;</a></span>lines_binning</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::lines_binning</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED lines_binning is the count of lines which are summed up in area mode for FFT sensors. When this is 1, every line is read out separately. When it is 2, every two lines are summed up in the sensor and read out as one line, so the count of samples for a complete readout gets divided by two. The same applies for higher values. lines_binning is a 12 bit unsigned integer. Further information about the area mode can be found in the manual in chapter 4.5.1.2.</p><ul>
<li>min: 1</li>
<li>step: 1</li>
<li>default: 1</li>
<li>max: 4095 </li>
</ul>

</div>
</div>
<a id="ab98246d4ee9f663d7b468f71821d7632" name="ab98246d4ee9f663d7b468f71821d7632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98246d4ee9f663d7b468f71821d7632">&#9670;&#160;</a></span>manipulate_data_custom_factor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double camera_settings::manipulate_data_custom_factor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>manipulate_data_custom_factor is used when <a class="el" href="#a108d24d1e3326657499f0c1ec387d005">camera_settings::manipulate_data_mode</a> is set to <a class="el" href="enum__settings_8h.html#aa60c841e2b61535475ffa273b78015f1a18242fd8c0e441e4a93bd5a928f6a09e">manipulate_data_mode_t::manipulate_data_mode_custom_factor</a>. This factor is multiplied with the data of each pixel. </p>

</div>
</div>
<a id="a108d24d1e3326657499f0c1ec387d005" name="a108d24d1e3326657499f0c1ec387d005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d24d1e3326657499f0c1ec387d005">&#9670;&#160;</a></span>manipulate_data_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::manipulate_data_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>With manipulate_data_mode you can activate / deactivate a built in data manipulation during the measurement. This is potentially used to linearize the sensor data for specific sensors. See <a class="el" href="enum__settings_8h.html#aa60c841e2b61535475ffa273b78015f1">manipulate_data_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="a87e6684676f13947b082dd5e7ab225b5" name="a87e6684676f13947b082dd5e7ab225b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e6684676f13947b082dd5e7ab225b5">&#9670;&#160;</a></span>monitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::monitor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>monitor is the output mode for the monitor output of the camera. See enum <a class="el" href="enum__settings_8h.html#a31d89bc528102fe4010591054c2dc5d1">monitor_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information about monitor can be found in the manual in chapter 3.3.1. </p>

</div>
</div>
<a id="aba505c7ed0e5a7488ea20f4caf52675b" name="aba505c7ed0e5a7488ea20f4caf52675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba505c7ed0e5a7488ea20f4caf52675b">&#9670;&#160;</a></span>number_of_regions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::number_of_regions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number_of_regions determines in how many regions the sensor gets divided when <a class="el" href="#a9a5b9370309e2391bdc0bdfbf7e9df15">camera_settings::fft_mode</a> is set to <a class="el" href="enum__settings_8h.html#a86f1e46308bfcaf8ceccb822f1d72c57a6f1771bc89a836bb050922037febfa51">fft_mode_t::partial_binning</a>. Setting it to 1 would equal the area mode, so the minimum is 2. The size of each region is determined by <a class="el" href="#a3fa31e4964a41c592d24ce74e4b7ce41">camera_settings::region_size</a>. Unused regions must be set to 0. Further information about the range of interest mode can be found in the manual in chapter 4.5.1.3.</p><ul>
<li>min: 2</li>
<li>step: 1</li>
<li>max: 5 </li>
</ul>

</div>
</div>
<a id="ad487b9bad9fa6aca6b18b4742c8ce417" name="ad487b9bad9fa6aca6b18b4742c8ce417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad487b9bad9fa6aca6b18b4742c8ce417">&#9670;&#160;</a></span>pixel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::pixel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pixel is the number of pixels in one sensor. Only 64*n are allowed. Pixel is a 16 bit unsigned integer. Typical values are: 576, 1024, 1088, 2112.</p><ul>
<li>min: 64</li>
<li>step: 64</li>
<li>max: 8256 </li>
</ul>

</div>
</div>
<a id="a3fa31e4964a41c592d24ce74e4b7ce41" name="a3fa31e4964a41c592d24ce74e4b7ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa31e4964a41c592d24ce74e4b7ce41">&#9670;&#160;</a></span>region_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::region_size[<a class="el" href="struct_8h.html#aec6ccacce4c15681a97f2edc0521040e">MAX_NUMBER_OF_REGIONS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>region_size is the size of each region for the region of interest mode for FFT sensors. The sum of all active regions, which is defined by <a class="el" href="#aba505c7ed0e5a7488ea20f4caf52675b">number_of_regions</a>, must equal <a class="el" href="#a74f4f26e7f43bf7f40bef828ac5849e0">fft_lines</a>. Inactive regions must be set to 0. region_size is a 32 bit unsigned integer array with the size of 8 but only 8 bit of each element are used. Further information about the range of interest mode can be found in the manual in chapter 4.5.1.3. This is an example for a region_size setting with fft_lines = 70 and number_of_regions = 3. Using this example the sensor will be read out 3 times. The first and the third read out contain the summed up intensity of the upper and the lower 4 lines. The second read out contains the intensity of the summed up 64 lines in between.</p><ul>
<li>region_size[0] = 4</li>
<li>region_size[1] = 64</li>
<li>region_size[2] = 4</li>
<li>region_size[3] = 0</li>
<li>region_size[4] = 0 </li>
</ul>

</div>
</div>
<a id="a725f47b587a2b425688fbd79586b989e" name="a725f47b587a2b425688fbd79586b989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725f47b587a2b425688fbd79586b989e">&#9670;&#160;</a></span>s1s2_read_delay_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::s1s2_read_delay_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>S1 S2 read delay in 10 ns controls the delay between the trigger and the moment, when the status of the S1 and S2 inputs are read. When the delay exceeds XCK, S1 and S2 are never read. S1 S2 read delay is a 32 bit unsigned integer. Further information information about S1 S2 read delay can be found in the manual in chapter 6.2.5.13.</p><ul>
<li>min: 0 ns</li>
<li>step: 10 ns</li>
<li>max: 4,294,967,295 * 10 ns = 42,949,672,950 ns </li>
</ul>

</div>
</div>
<a id="afdbb58aa78c6d9d9210c244507de9c68" name="afdbb58aa78c6d9d9210c244507de9c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbb58aa78c6d9d9210c244507de9c68">&#9670;&#160;</a></span>sdat_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sdat_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan delay after trigger in 10 ns steps is the delay time between the trigger starting a scan, which is determined by sti_mode and the actual start of the scan. SDAT is a 31 bit unsigned integer. Further information about sdat can be found in the manual in chapter 2.9.2 and 6.2.4.10.</p><ul>
<li>disable: 0</li>
<li>min: 1 * 10 ns = 10 ns</li>
<li>step: 10 ns</li>
<li>max: 2,147,483,647 * 10 ns = 21,474,836,470 ns = 21.474836470 s </li>
</ul>

</div>
</div>
<a id="adef56c9e33dc855c930fd7d44588cbcd" name="adef56c9e33dc855c930fd7d44588cbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef56c9e33dc855c930fd7d44588cbcd">&#9670;&#160;</a></span>sec_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sec_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan exposure control in 10 ns steps adds a delay time between the trigger and the start of the camera read out (start of XCK). Some sensors use this time for a electronic exposure control. Also mechanical shutters can be controlled with this setting. The SEC time is added between the end of SDAT and the start of the camera read out. SEC is a 32 bit unsigned integer. Further information about SEC can be found in the manual in chapter 4.9.1 and 6.2.4.11.</p><ul>
<li>disable: 0</li>
<li>min: 1 * 10 ns = 10 ns</li>
<li>step: 10 ns</li>
<li>max: 4,294,967,295 * 10 ns = 42,949,672,950 ns </li>
</ul>

</div>
</div>
<a id="ac7aefaf11767a16726f85379d288895b" name="ac7aefaf11767a16726f85379d288895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7aefaf11767a16726f85379d288895b">&#9670;&#160;</a></span>sensor_gain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sensor_gain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sensor gain is controlling the internal gain function of some infrared sensors. For the some sensors gain can be switched on or off, others sensor got multiple levels of gain. Further information about sensor gain can be found in the manual in chapters 3.3.1, 3.4.1.1, 4.5.2, 8.4.4, 8.7.3.</p><ul>
<li>camera system 3001/3010:<ul>
<li>gain off: 0</li>
<li>gain on: 1</li>
</ul>
</li>
<li>camera system 3030:<ul>
<li>gain off: 0</li>
<li>step: 1</li>
<li>max gain: 3 </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a2e848de09b699a99f976b67297acbd15" name="a2e848de09b699a99f976b67297acbd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e848de09b699a99f976b67297acbd15">&#9670;&#160;</a></span>sensor_reset_or_hsir_ec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sensor_reset_or_hsir_ec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sensor_reset_or_hsir_ec either controls the length of the reset pulse between two camera readouts or the exposure time of the high speed infrared sensor. The purpose of this setting depends on <a class="el" href="#a3c95b63babcb2222a271e2cd42b6e057">camera_settings::sensor_type</a>. sensor_reset_or_hsir_ec is a 16 bit unsigned integer.</p>
<p>Sensor reset for HSVIS: This reset can be used, to completely clear the sensor. Further information about sensor reset can be found in the manual in chapter 4.9.2.</p><ul>
<li>min: 0 ns</li>
<li>step: 1 * 4 ns = 4 ns</li>
<li>default: 100 * 4 ns = 400 ns</li>
<li>max: 65535 * 4 ns = 262,140 ns</li>
</ul>
<p>Exposure control for HSIR: When sensor_type is HSIR this setting controls the exposure time of the sensor. The exposure time cannot be shorter than the minimum. If the value is smaller than the minimum the exposure time will be the minumum. If the value exceeds the repetition rate of the measurement, there will be samples with a zero line.</p><ul>
<li>min: 134 * 160 ns = 21,440 ns</li>
<li>step: 1 * 160 ns = 160 ns</li>
<li>default: 140 * 160 ns = 22,400 ns</li>
<li>max: 65535 * 160 ns = 10,485,600 ns </li>
</ul>

</div>
</div>
<a id="a3c95b63babcb2222a271e2cd42b6e057" name="a3c95b63babcb2222a271e2cd42b6e057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c95b63babcb2222a271e2cd42b6e057">&#9670;&#160;</a></span>sensor_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sensor_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sensor type should match the sensor type of your camera. See enum <a class="el" href="enum__settings_8h.html#a089f166159fb19f10d81c65c1d8793a2">sensor_type_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="a02fa99eaf64c0df8af0ffd6ce1b5497c" name="a02fa99eaf64c0df8af0ffd6ce1b5497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fa99eaf64c0df8af0ffd6ce1b5497c">&#9670;&#160;</a></span>shift_s1s2_to_next_scan</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::shift_s1s2_to_next_scan</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When shift S1S2 to next scan is on, the input states of S1 and S2, which are sampled in scan n, are displayed in pixel 2 in scan n+1. This option is useful for the sensor type HSIR, because this camera displays the data sampled at trigger n in scan n+1. To match the actual states of S1 and S2 to the sensor data activate this option. This feature is supported since PCIe board version P222_17.</p><ul>
<li>=0: off</li>
<li>=1: on </li>
</ul>

</div>
</div>
<a id="a6f55940576ecb2bced3027d38676ea5c" name="a6f55940576ecb2bced3027d38676ea5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f55940576ecb2bced3027d38676ea5c">&#9670;&#160;</a></span>sslope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sslope</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan trigger slope determines whether positive, negative or both slopes of a trigger are used. See enum <a class="el" href="enum__settings_8h.html#a807bb0212417bc8c5b431aad2fbc2f00">sslope_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. This only applies to external triggers. </p>

</div>
</div>
<a id="afeb4693c3f62bd567f9063c0412035b5" name="afeb4693c3f62bd567f9063c0412035b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb4693c3f62bd567f9063c0412035b5">&#9670;&#160;</a></span>sti_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sti_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan trigger input mode determines the signal, on which one readout is started. See enum <a class="el" href="enum__settings_8h.html#a0bdcebe838e77385002ccc4077a6e743">sti_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information on trigger signals can be found in the manual in chapter 6.3. </p>

</div>
</div>
<a id="a95629ef99d7173af90b835efd29b4eb9" name="a95629ef99d7173af90b835efd29b4eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95629ef99d7173af90b835efd29b4eb9">&#9670;&#160;</a></span>sticnt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::sticnt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan trigger input counter determines how many scan trigger inputs are skipped before the next measurement is triggered. Every sticnt+1 trigger input the measurement is triggered according to <a class="el" href="#afeb4693c3f62bd567f9063c0412035b5">camera_settings::sti_mode</a>. sticnt is a 7 bit unsigned integer. Further information about sticnt can be found in the manual in chapter 6.2.4.12.</p><ul>
<li>min: 0</li>
<li>step: 1</li>
<li>max: 127 </li>
</ul>

</div>
</div>
<a id="a10e94844da7b9228d8ba9c2bd14310cb" name="a10e94844da7b9228d8ba9c2bd14310cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e94844da7b9228d8ba9c2bd14310cb">&#9670;&#160;</a></span>stime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::stime</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stime is the time between the start of two readouts. This time is used when <a class="el" href="#afeb4693c3f62bd567f9063c0412035b5">camera_settings::sti_mode</a> is set to <a class="el" href="enum__settings_8h.html#a0bdcebe838e77385002ccc4077a6e743a8ef1e8da5911430f6487c240f981d735">sti_mode_t::sti_STimer</a>. The resolution of this timer depends on the setting <a class="el" href="#a8bb5552267c411cc54baf8b800967ead">camera_settings::timer_resolution_mode</a>. Stime is a 28 bit unsigned integer. Further information about the timer can be found in the manual in chapter 6.4.4. </p>

</div>
</div>
<a id="a5949285bc39a601900f8d975444e492d" name="a5949285bc39a601900f8d975444e492d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949285bc39a601900f8d975444e492d">&#9670;&#160;</a></span>temp_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::temp_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temperature level is controlling the target temperature for the temperature regulation in cooled cameras. The cooling is done by a Peltier element which can generate a temperature difference of 40 C. That means the target temperature can only be reached, if the ambient temperature is not higher than target + 40 C. The regulation is optimized for -20 C to 0 C. The precision is 1 K at these levels. On other levels the error can rise up to 10 K. If the target temperature is reached, the LED TG (Temperature Good) will light up green. temp_level is a 3 bit unsigned integer. Further information about temp_level can be found in the manual in chapter 3.5.</p><ul>
<li>0: cooling off</li>
<li>1: 0 C</li>
<li>2: -10 C</li>
<li>3: -20 C</li>
<li>4: -25 C</li>
<li>5: -30 C</li>
<li>6: -40 C</li>
<li>7: min C </li>
</ul>

</div>
</div>
<a id="a8bb5552267c411cc54baf8b800967ead" name="a8bb5552267c411cc54baf8b800967ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb5552267c411cc54baf8b800967ead">&#9670;&#160;</a></span>timer_resolution_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::timer_resolution_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>timer_resolution_mode determines the resolution of the timer controlled by <a class="el" href="#a10e94844da7b9228d8ba9c2bd14310cb">camera_settings::stime</a> and <a class="el" href="#a0f6f87c7fca887ea0bc1f5f16ff90f94">camera_settings::btime</a>. See <a class="el" href="enum__settings_8h.html#ac3d3af5007ef448a128969d75f2a398f">timer_resolution_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. </p>

</div>
</div>
<a id="a9d36d06df4f4506a30632260bf6b1939" name="a9d36d06df4f4506a30632260bf6b1939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d36d06df4f4506a30632260bf6b1939">&#9670;&#160;</a></span>tocnt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::tocnt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger output counter determines how many XCK are skipped until the output TO_CNT_OUT shows the XCK signal. Use <a class="el" href="enum__settings_8h.html#a34afd11285290b35c0f65d59c163fafaa21d1f38219ac0747f5113977709e5301">tor_out_t::tor_to_cnt_out</a> for the setting <a class="el" href="#ac9a0cd5c6fc15fb192e18d623cffca0d">camera_settings::tor</a> to see TO_CNT_OUT at the output of the PCIe board. Example: tocnt = 2 =&gt; skip every first and second XCK, show XCK on the PCIe output on every third XCK. tocnt is a 7 bit unsigned integer. Further information about tocnt can be found in the manual in chapter 6.2.4.12.</p><ul>
<li>min: 0 (TO_CNT_OUT = XCK)</li>
<li>step: 1</li>
<li>max: 127 </li>
</ul>

</div>
</div>
<a id="ac9a0cd5c6fc15fb192e18d623cffca0d" name="ac9a0cd5c6fc15fb192e18d623cffca0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a0cd5c6fc15fb192e18d623cffca0d">&#9670;&#160;</a></span>tor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::tor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output mode for PCIe board output pin. See enum <a class="el" href="enum__settings_8h.html#a34afd11285290b35c0f65d59c163fafa">tor_out_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information about tor can be found in the manual in chapter 6.2.4.12. </p>

</div>
</div>
<a id="a81d92a0475fbf332ef99de9748d6b197" name="a81d92a0475fbf332ef99de9748d6b197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d92a0475fbf332ef99de9748d6b197">&#9670;&#160;</a></span>trigger_mode_integrator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::trigger_mode_integrator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger mode of the integrator in the camera control box. See enum <a class="el" href="enum__settings_8h.html#a6d33f21be3f0c5cf91c5d638e8aca086">trigger_mode_t</a> in <a class="el" href="enum__settings_8h.html" title="All settings options and software constants.">enum_settings.h</a> for options. Further information about the trigger modes can found in the manual in chapter 7.3.7. </p>

</div>
</div>
<a id="a7d6d06fc3f59976df702bfda1e7bc0d1" name="a7d6d06fc3f59976df702bfda1e7bc0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6d06fc3f59976df702bfda1e7bc0d1">&#9670;&#160;</a></span>use_software_polling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::use_software_polling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>use_software_polling determines which method is used to copy data from DMA to user buffer.</p><ul>
<li>&gt;0: Use software polling. When there is new available data in the DMA buffer, a thread copies the data one scan at a time to the user buffer. Since the PCIe card firmware version P222_2 this method is reliable up to about 100kHz. It generates as expected a higher CPU load than the interrupt method. With this option you can get more recent scans from <a class="el" href="_e_s_l_s_c_d_l_l_8c.html#a79a1ea8d164b02336350f228840b1c02">DLLGetCurrentScanNumber</a>, especially at lower frequencies.</li>
<li>=0: Use interrupt. Every <a class="el" href="#a8f2833d2036671abc6382415794d6032">camera_settings::dma_buffer_size_in_scans</a> /2 scan the interrupt starts a copy process, which copies dma_buffer_size_in_scans/2 scans to the user buffer. 1000 is our default value for <a class="el" href="#a8f2833d2036671abc6382415794d6032">camera_settings::dma_buffer_size_in_scans</a>, so the interrupt is triggered every 500 scans.</li>
</ul>
<p>Further information about software polling can be found in the manual in chapter 5.4.8. </p>

</div>
</div>
<a id="a2e34276300a6c0e2a56a8404b73ad8de" name="a2e34276300a6c0e2a56a8404b73ad8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e34276300a6c0e2a56a8404b73ad8de">&#9670;&#160;</a></span>vfreq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::vfreq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vfreq controls the vertical clock frequency for FFT sensors. Different sensors are capable of different vertical clock speeds, so this setting should match your sensor. You can find this information in the manual. vfreq is the period of the vertical clock, so a higher vfreq means a lower frequency. vfreq is 8 bit unsigned integer. Further information about vfreq and FFT sensors can be found in the manual in chapters 1.4, 3.3.5 and 11.3.3.</p><ul>
<li>min: 1 * 256 ns = 256 ns =&gt; 3.9 MHz</li>
<li>step: 1 * 256 ns = 256 ns</li>
<li>max: 255 * 256 ns = 65,280 ns =&gt; 15.3 kHz </li>
</ul>

</div>
</div>
<a id="a87115a7a52a7b6f474bb12ab3a2db076" name="a87115a7a52a7b6f474bb12ab3a2db076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87115a7a52a7b6f474bb12ab3a2db076">&#9670;&#160;</a></span>write_to_disc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::write_to_disc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to disc is an experimental feature for writing the measurement data on the fly to the disc. The data format is binary. It is the same data layout as the data is stored in RAM during the measurement. Additionally there is a file header at the beginning of the file. The path to the target file is given by <a class="el" href="#a87267de87e955bd0f244798f48d0c6df">camera_settings::file_path</a>. This feature is only available on Windows. In most cases the resulting file should be correct, but data layout errors has been observed. This is the reason why the feature is marked as experimental.</p><ul>
<li>=0: Don't write measurement data to disc.</li>
<li>&gt;0: Write measurement data to disc. </li>
</ul>

</div>
</div>
<a id="a7b34c90094bcbc83b418f3b613f6c8d7" name="a7b34c90094bcbc83b418f3b613f6c8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b34c90094bcbc83b418f3b613f6c8d7">&#9670;&#160;</a></span>xckdelay_in_10ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t camera_settings::xckdelay_in_10ns</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LEGACY XCK delay in 10 ns steps was the time between the high slope of XCK and the actual start of the camera read out. This is done by delaying VON relative to XCK. Since P222_09 cameras are not designed to interact with the VON signal anymore. For the following camera versions xckdelay can be used:</p><ul>
<li>205.X</li>
<li>215.6 and older</li>
<li>206.X</li>
<li>216.X For newer camera versions VCLKs are generated inside the camera and the delay between integrator and XCK can be achieved by using the analog delay of the camera control. Further information about xckdelay can be found in the manual in chapter 6.2.5.12. 31 bit. xckdelay = 500ns + xckdelay_in_10ns * 10ns</li>
<li>disable: 0</li>
<li>min 1: 500 ns + 1 * 10ns = 510 ns</li>
<li>max 2,147,483,647: 500 ns + 2,147,483,647 * 10 ns = 21,474,836,970 ns = 21.474836970 s </li>
</ul>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/github/workspace/shared_src/<a class="el" href="struct_8h_source.html">struct.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
